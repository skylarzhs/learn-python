# 常用内建模块

## datetime

datetime是Python处理日期和时间的标准库。

### 获取当前日期和时间

```
>>> from datetime import datetime
>>> now = datetime.now()
>>> now
datetime.datetime(2020, 4, 14, 16, 31, 58, 943463)
>>> type(now)
<class 'datetime.datetime'>
```

### datetime转换为timestamp

把一个datetime类型转换为timestamp只需要简单调用timestamp()方法

### 获取指定日期和时间

要指定某个日期和时间，我们直接用参数构造一个datetime

### timestamp转换为datetime

要把timestamp转换为datetime，使用datetime提供的fromtimestamp()方法：

utcfromtimestamp() 获取UTC时间



### str转换为datetime

很多时候，用户输入的日期和时间是字符串，要处理日期和时间，首先必须把str转换为datetime。转换方法是通过datetime.strptime()实现，需要一个日期和时间的格式化字符串

### datetime加减

对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类

```
>>> from datetime import timedelta
>>> now = datetime.now()
>>> now
datetime.datetime(2020, 4, 14, 17, 0, 34, 66647)
>>> now + timedelta(hours=1)
datetime.datetime(2020, 4, 14, 18, 0, 34, 66647)
>>> now + timedelta(hours=-1)
datetime.datetime(2020, 4, 14, 16, 0, 34, 66647)
>>> now + timedelta(days=-1)  
datetime.datetime(2020, 4, 13, 17, 0, 34, 66647)
>>> now + timedelta(days=1)  
datetime.datetime(2020, 4, 15, 17, 0, 34, 66647)
>>> now + timedelta(days=1,hours=2)
datetime.datetime(2020, 4, 15, 19, 0, 34, 66647)
>>> now - timedelta(days=1)
datetime.datetime(2020, 4, 13, 17, 0, 34, 66647)
>>> now - timedelta(days=1,hours=9)
datetime.datetime(2020, 4, 13, 8, 0, 34, 66647)
```

### 本地时间转换为UTC时间

本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。

一个datetime类型有一个时区属性tzinfo，但是默认为None，所以无法区分这个datetime到底是哪个时区，除非强行给datetime设置一个时区：

## collections

collections是Python内建的一个集合模块，提供了许多有用的集合类。

### namedtuple

namedtuple是一个函数，它用来创建一个自定义的tuple对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素。

这样一来，我们用namedtuple可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用，使用十分方便。

```
>>> from collections import namedtuple
>>> Point = namedtuple('Point',['x','y']) 
>>> p = Point(1,2) 
>>> p
Point(x=1, y=2)
>>> p = Point(1,2,3) 
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: __new__() takes 3 positional arguments but 4 were given
>>> isinstance(p,Point) 
True
>>> isinstance(p,tuple) 
True
>>> p.x
1
>>> Circle = namedtuple('Circle',['x','y','r']) 
>>> c = Circle(3,3,3) 
>>> c
Circle(x=3, y=3, r=3)
```

### deque

deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈

```
>>> from collections import deque
>>> q = deque([1,2,3,4]) 
>>> q
deque([1, 2, 3, 4])
>>> q.append('last') 
>>> q
deque([1, 2, 3, 4, 'last'])
>>> q.appendleft('first') 
>>> q
deque(['first', 1, 2, 3, 4, 'last'])
>>> q.pop()
'last'
>>> q
deque(['first', 1, 2, 3, 4])
>>> q.popleft() 
'first'
>>> q
deque([1, 2, 3, 4])
```

### defaultdict

使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用defaultdic

```
>>> from collections import defaultdict
>>> dd = defaultdict(lambda : 'N/A') 
>>> dd
defaultdict(<function <lambda> at 0x000001CBB8C49C10>, {})
>>> dd['k1'] = 123
>>> dd['k1'] 
123
>>> dd['k2'] 
'N/A'
```

注意默认值是调用函数返回的，而函数在创建defaultdict对象时传入。

除了在Key不存在时返回默认值，defaultdict的其他行为跟dict是完全一样的。

### OrderedDict

OrderedDict的Key会按照插入的顺序排列，不是Key本身排序。

OrderedDict可以实现一个[FIFO](../Exercise/61.ordered_dict.py)（先进先出）的dict，当容量超出限制时，先删除最早添加的Key。

### ChainMap

ChainMap可以把一组dict串起来并组成一个逻辑上的dict。ChainMap本身也是一个dict，但是查找的时候，会按照顺序在内部的dict依次查找。

什么时候使用ChainMap最合适？举个例子：应用程序往往都需要传入参数，参数可以通过命令行传入，可以通过环境变量传入，还可以有默认参数。我们可以用ChainMap实现参数的优先级查找，即先查命令行参数，如果没有传入，再查环境变量，如果没有，就使用默认参数。

[示例代码](../Exercise/62.ChainMap.py)

### Counter

Counter是一个简单的计数器，例如，统计字符出现的个数。

```
>>> from collections import Counter
>>> Counter({'a':1}) 
Counter({'a': 1})
>>> c = Counter()
>>> for ch in 'programming':
...     c[ch] = c[ch] + 1
... 
>>> c
Counter({'r': 2, 'g': 2, 'm': 2, 'p': 1, 'o': 1, 'a': 1, 'i': 1, 'n': 1})
>>> c.update('Hello') 
>>> c
Counter({'r': 2, 'o': 2, 'g': 2, 'm': 2, 'l': 2, 'p': 1, 'a': 1, 'i': 1, 'n': 1, 'H': 1, 'e': 1})
```

## base64

Base64是一种用64个字符来表示任意二进制数据的方法。

用记事本打开exe、jpg、pdf这些文件时，我们都会看到一大堆乱码，因为二进制文件包含很多无法显示和打印的字符，所以，如果要让记事本这样的文本处理软件能处理二进制数据，就需要一个二进制到字符串的转换方法。Base64是一种最常见的二进制编码方法。

Base64的原理很简单，首先，准备一个包含64个字符的数组：

```
['A', 'B', 'C', ... 'a', 'b', 'c', ... '0', '1', ... '+', '/']
```

然后，对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit

![](static/image/64.png)

这样我们得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串。

所以，Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。

如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用\x00字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。

Python内置的base64可以直接进行base64的编解码。

由于标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数，所以又有一种"url safe"的base64编码，其实就是把字符+和/分别变成-和_

```
>>> import base64
>>> base64.b64encode(b'binary\x00string') 
b'YmluYXJ5AHN0cmluZw=='
>>> base64.b64encode(b'YmluYXJ5AHN0cmluZw==') 
b'WW1sdVlYSjVBSE4wY21sdVp3PT0='
>>> base64.b64decode(b'YmluYXJ5AHN0cmluZw==') 
b'binary\x00string'
>>> base64.b64encode(b'i\xb7\x1d\xfb\xef\xff')
b'abcd++//'
>>> base64.urlsafe_b64encode(b'i\xb7\x1d\xfb\xef\xff')
b'abcd--__'
>>> base64.urlsafe_b64decode('abcd--__')
b'i\xb7\x1d\xfb\xef\xff'
>>> base64.b64encode(b'abcd') 
```

Base64是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行。

Base64适用于小段内容的编码，比如数字证书签名、Cookie的内容等。

由于=字符也可能出现在Base64编码中，但=用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把=去掉;Base64是把3个字节变为4个字节，所以，Base64编码的长度永远是4的倍数，因此，需要加上=把Base64字符串的长度变为4的倍数，就可以正常解码了

[练习题](../Exercise/63.base64.py)

## struct

struct模块来解决bytes和其他二进制数据类型的转换。

struct的pack函数把任意数据类型变成bytes。

pack的第一个参数是处理指令，'>I'的意思是：>表示字节顺序是big-endian，也就是网络序，I表示4字节无符号整数。后面的参数个数要和处理指令一致。

```
>>> import struct
>>> struct.pack('>I', 10240099)
b'\x00\x9c@c'
```

unpack把bytes变成相应的数据类型：

```
>>> struct.unpack('>IH', b'\xf0\xf0\xf0\xf0\x80\x80')
(4042322160, 32896)
```

根据>IH的说明，后面的bytes依次变为I：4字节无符号整数和H：2字节无符号整数。

BMP格式采用小端方式存储数据，文件头的结构按顺序如下：

两个字节：'BM'表示Windows位图，'BA'表示OS/2位图； 一个4字节整数：表示位图大小； 一个4字节整数：保留位，始终为0； 一个4字节整数：实际图像的偏移量； 一个4字节整数：Header的字节数； 一个4字节整数：图像宽度； 一个4字节整数：图像高度； 一个2字节整数：始终为1； 一个2字节整数：颜色数。

```
>>> s = ct[:30]
>>> s
b'BM6\xf3\x00\x00\x00\x00\x00\x006\x00\x00\x00(\x00\x00\x00\x90\x00\x00\x00\x90\x00\x00\x00\x01\x00\x18\x00'
>>> struct.unpack('<ccIIIIIIHH', s)
(b'B', b'M', 62262, 0, 54, 40, 144, 144, 1, 24)
```