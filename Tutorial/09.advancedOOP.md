# 面向对象高级编程

## 使用__slots__

正常情况下，当我们定义了一个class，创建一个class实例之后，可以给该实例绑定任何属性和方法。

给当前实例绑定的属性和方法只能当前实例使用，其他实例需要重新绑定。

给class绑定属性与方法，所有实例都可以调用。

Python允许在定义class的时候，定义一个特殊的`__slots__`变量，限制该class的实例能添加的属性。

```
__slots__ = ('attr1','attr2') # 用tuple定义允许的属性名称
```

`__slots__`定义的属性仅对当前类实例起作用，对继承的子类是不起作用的，除非在子类中也定义`__slots__`，这样，子类实例允许定义的属性就是自身的`__slots__`加上父类的`__slots__`。

## 使用@property

Python内置的@property装饰器就是负责把一个方法变成属性调用的。

把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作。

注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。

还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性。

## 多重继承

多重继承，一个子类可以同时获得多个父类的所有功能。

在设计类的继承关系时，通常，主线都是单一继承下来的，如果需要混入额外的功能，通过多重继承实现，这种设计通常称为`MixIn`。

`MixIn`的目的就是给一个类增加多个功能，这样，在设计类的时候。我们优先考虑通过多重继承的组合多个MixIn的功能，而不是设计做层次的复杂的集成关系。

## 定制类

`__str__()`
    定义实例打印字符串。
    同类：`__repr__()`
    直接显示变量调用的不是`__str__()`，而是`__repr__()`，两者的区别是`__str__()`返回用户看到的字符串，而`__repr__()`返回程序开发者看到的字符串，也就是说，`__repr__()`是为调试服务的。
    通常`__str__()`和`__repr__()`代码都是一样的，可以直接定义`__repr__ = __str__`

`__iter__`
    如果一个类想被用于`for ... in`循环，类似`list`或`tuple`那样，就必须实现一个`__iter__()`方法，该方法返回一个迭代对象，然后，Python的`for`循环就会不断调用该迭代对象的`__next__()`方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。

`__getitem__`
    与之对应的是`__setitem__()`方法，把对象视作`list`或`dict`来对集合赋值。最后，还有一个`__delitem__()`方法，用于删除某个元素。

`__getattr__`
    作用就是，可以针对完全动态的情况作调用。

`__call__`
    一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用`instance.method()`来调用。
    任何类，只需要定义一个`__call__()`方法，就可以直接对实例进行调用。
    `__call__()`还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。
    通过`callable()`函数，我们就可以判断一个对象是否是“可调用”对象。

## 使用枚举类

```
from enum import Enum

Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))

for name, member in Month.__members__.items():
    print(name, '=>', member, ',', member.value) #value属性则是自动赋给成员的int常量，默认从1开始计数。
```

从Enum派生出自定义类
```
from enum import Enum, unique

@unique
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6
```

## 使用元类

动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。

`type()`
    class的定义是运行时动态创建的，而创建class的方法就是使用`type()`函数。
    type()函数既可以返回一个对象的类型，又可以创建出新的类型。
    要创建一个class对象，`type()`函数依次传入3个参数：
        class的名称；
        继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；
        class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。
    通过`type()`函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用`type()`函数创建出class。
    正常情况下，我们都用`class Xxx...`来定义类，但是，`type()`函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。

`metaclass`
