# 面向对象高级编程

## 使用__slots__

正常情况下，当我们定义了一个class，创建一个class实例之后，可以给该实例绑定任何属性和方法。

给当前实例绑定的属性和方法只能当前实例使用，其他实例需要重新绑定。

给class绑定属性与方法，所有实例都可以调用。

Python允许在定义class的时候，定义一个特殊的`__slots__`变量，限制该class的实例能添加的属性。

```
__slots__ = ('attr1','attr2') # 用tuple定义允许的属性名称
```

`__slots__`定义的属性仅对当前类实例起作用，对继承的子类是不起作用的，除非在子类中也定义`__slots__`，这样，子类实例允许定义的属性就是自身的`__slots__`加上父类的`__slots__`。

## 使用@property

Python内置的@property装饰器就是负责把一个方法变成属性调用的。

把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作。

注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。

还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性。

## 多重继承

多重继承，一个子类可以同时获得多个父类的所有功能。

在设计类的继承关系时，通常，主线都是单一继承下来的，如果需要混入额外的功能，通过多重继承实现，这种设计通常称为`MixIn`。

`MixIn`的目的就是给一个类增加多个功能，这样，在设计类的时候。我们优先考虑通过多重继承的组合多个MixIn的功能，而不是设计做层次的复杂的集成关系。

## 定制类

`__str__()`
    定义实例打印字符串。
    同类：`__repr__()`
    直接显示变量调用的不是`__str__()`，而是`__repr__()`，两者的区别是`__str__()`返回用户看到的字符串，而`__repr__()`返回程序开发者看到的字符串，也就是说，`__repr__()`是为调试服务的。
    通常`__str__()`和`__repr__()`代码都是一样的，可以直接定义`__repr__ = __str__`

`__iter__`
    
    
## 使用枚举类

## 使用元类
