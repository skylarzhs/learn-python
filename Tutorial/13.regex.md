# 正则表达式

正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。

\d \w \s . * {n,m}

要做更精确地匹配，可以用[]表示范围，比如：

`[0-9a-zA-Z\_]`可以匹配一个数字、字母或者下划线；

`[0-9a-zA-Z\_]+`可以匹配至少由一个数字、字母或者下划线组成的字符串，比如'a100'，'0_Z'，'Py3000'等等；

`[a-zA-Z\_][0-9a-zA-Z\_]*`可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；

`[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}`更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。

`A|B`可以匹配A或B，所以`(P|p)ython`可以匹配`'Python'`或者`'python'`。

`^`表示行的开头，`^\d`表示必须以数字开头。

`$`表示行的结束，`\d$`表示必须以数字结束。

你可能注意到了，`py`也可以匹配`'python'`，但是加上`^py$`就变成了整行匹配，就只能匹配`'py'`了。

## re模块

Python提供`re`模块，包含所有正则表达式的功能。由于Python的字符串本身也用\转义，所以要特别注意。

强烈建议使用Python的`r`前缀，就不用考虑转义的问题了。

`match()`方法判断是否匹配，如果匹配成功，返回一个`Match`对象，否则返回`None`。常见的判断方法就是:

```
test = '用户输入的字符串'
if re.match(r'正则表达式', test):
    print('ok')
else:
    print('failed')
```

## 切分字符串

更加灵活。

```
>>> re.split(r'[\s\,\;]+', 'a,b;; c  d')
['a', 'b', 'c', 'd']
```

## 分组

用()表示的就是要提取的分组（Group）。

```
>>> m = re.match(r'(\d{3})\-(\d{3,8})','010-123245')
>>> m
<re.Match object; span=(0, 10), match='010-123245'>
>>> m.group(0)
'010-123245'
>>> m.group(1)
'010'
>>> m.group(2)
'123245'
>>> m.groups()
('010', '123245')
```

## 贪婪匹配

`?`

## 编译

当我们在Python中使用正则表达式时，re模块内部会干两件事情：

1. 编译正则表达式，如果正则表达式的字符串本身不合法，会报错；

2. 用编译后的正则表达式去匹配字符串。

如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：

```
>>> re_tel = re.compile(r'^(\d{3})\-(\d{3,8})$')
>>> re_tel.match('010-9090').groups()
('010', '9090')
>>> re_tel.match('010-998790').groups()
('010', '998790')
```
